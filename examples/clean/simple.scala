// Generated by aps2scala version 0.3.6
import basic_implicit._;
object simple_implicit {
  val simple_loaded = true;
}
import simple_implicit._;

trait C_SIMPLE[T_Result] extends C_TYPE[T_Result] {
  type T_Program <: Node;
  val t_Program : C_PHYLUM[T_Program];
  type T_Block <: Node;
  val t_Block : C_PHYLUM[T_Block];
  type T_Decls <: Node;
  val t_Decls : C_PHYLUM[T_Decls];
  type T_Decl <: Node;
  val t_Decl : C_PHYLUM[T_Decl];
  type T_Type <: Node;
  val t_Type : C_PHYLUM[T_Type];
  type T_Stmts <: Node;
  val t_Stmts : C_PHYLUM[T_Stmts];
  type T_Stmt <: Node;
  val t_Stmt : C_PHYLUM[T_Stmt];
  type T_Expr <: Node;
  val t_Expr : C_PHYLUM[T_Expr];
  val p_program : PatternFunction[(T_Program,T_Block)];
  def v_program : (T_Block) => T_Program;
  val p_block : PatternFunction[(T_Block,T_Decls,T_Stmts)];
  def v_block : (T_Decls,T_Stmts) => T_Block;
  val p_no_decls : PatternFunction[(T_Decls)];
  def v_no_decls : () => T_Decls;
  val p_xcons_decls : PatternFunction[(T_Decls,T_Decls,T_Decl)];
  def v_xcons_decls : (T_Decls,T_Decl) => T_Decls;
  val p_decl : PatternFunction[(T_Decl,T_String,T_Type)];
  def v_decl : (T_String,T_Type) => T_Decl;
  val p_integer_type : PatternFunction[(T_Type)];
  def v_integer_type : () => T_Type;
  val p_string_type : PatternFunction[(T_Type)];
  def v_string_type : () => T_Type;
  val p_no_stmts : PatternFunction[(T_Stmts)];
  def v_no_stmts : () => T_Stmts;
  val p_xcons_stmts : PatternFunction[(T_Stmts,T_Stmts,T_Stmt)];
  def v_xcons_stmts : (T_Stmts,T_Stmt) => T_Stmts;
  val p_block_stmt : PatternFunction[(T_Stmt,T_Block)];
  def v_block_stmt : (T_Block) => T_Stmt;
  val p_assign_stmt : PatternFunction[(T_Stmt,T_Expr,T_Expr)];
  def v_assign_stmt : (T_Expr,T_Expr) => T_Stmt;
  val p_intconstant : PatternFunction[(T_Expr,T_Integer)];
  def v_intconstant : (T_Integer) => T_Expr;
  val p_strconstant : PatternFunction[(T_Expr,T_String)];
  def v_strconstant : (T_String) => T_Expr;
  val p_variable : PatternFunction[(T_Expr,T_String)];
  def v_variable : (T_String) => T_Expr;
}

abstract class T_SIMPLE(t : C_SIMPLE[T_SIMPLE]) extends Value(t) { }

class M_SIMPLE(name : String)
  extends I_TYPE[T_SIMPLE](name)
  with C_SIMPLE[T_SIMPLE]
{
  val t_Result : this.type = this;
  abstract class T_Program(t : I_PHYLUM[T_Program]) extends Node(t) {
    override def isRooted : Boolean = true;
  }
  val t_Program = new I_PHYLUM[T_Program]("Program");

  abstract class T_Block(t : I_PHYLUM[T_Block]) extends Node(t) {}
  val t_Block = new I_PHYLUM[T_Block]("Block");

  abstract class T_Decls(t : I_PHYLUM[T_Decls]) extends Node(t) {}
  val t_Decls = new I_PHYLUM[T_Decls]("Decls");

  abstract class T_Decl(t : I_PHYLUM[T_Decl]) extends Node(t) {}
  val t_Decl = new I_PHYLUM[T_Decl]("Decl");

  abstract class T_Type(t : I_PHYLUM[T_Type]) extends Node(t) {}
  val t_Type = new I_PHYLUM[T_Type]("Type");

  abstract class T_Stmts(t : I_PHYLUM[T_Stmts]) extends Node(t) {}
  val t_Stmts = new I_PHYLUM[T_Stmts]("Stmts");

  abstract class T_Stmt(t : I_PHYLUM[T_Stmt]) extends Node(t) {}
  val t_Stmt = new I_PHYLUM[T_Stmt]("Stmt");

  abstract class T_Expr(t : I_PHYLUM[T_Expr]) extends Node(t) {}
  val t_Expr = new I_PHYLUM[T_Expr]("Expr");

  case class c_program(v_block : T_Block) extends T_Program(t_Program) {
    override def children : List[Node] = List(v_block);
    override def toString() : String = Debug.with_level {
      "program("+ v_block+ ")";
    }
  }
  def u_program(x:Any) : Option[(T_Program,T_Block)] = x match {
    case x@c_program(v_block) => Some((x,v_block));
    case _ => None };
  val v_program = f_program _;
  def f_program(v_block : T_Block):T_Program = c_program(v_block).register;
  val p_program = new PatternFunction[(T_Program,T_Block)](u_program);

  case class c_block(v_decls : T_Decls,v_stmts : T_Stmts) extends T_Block(t_Block) {
    override def children : List[Node] = List(v_decls,v_stmts);
    override def toString() : String = Debug.with_level {
      "block("+ v_decls + ","+ v_stmts+ ")";
    }
  }
  def u_block(x:Any) : Option[(T_Block,T_Decls,T_Stmts)] = x match {
    case x@c_block(v_decls,v_stmts) => Some((x,v_decls,v_stmts));
    case _ => None };
  val v_block = f_block _;
  def f_block(v_decls : T_Decls, v_stmts : T_Stmts):T_Block = c_block(v_decls,v_stmts).register;
  val p_block = new PatternFunction[(T_Block,T_Decls,T_Stmts)](u_block);

  case class c_no_decls() extends T_Decls(t_Decls) {
    override def children : List[Node] = List();
    override def toString() : String = Debug.with_level {
      "no_decls("+ ")";
    }
  }
  def u_no_decls(x:Any) : Option[(T_Decls)] = x match {
    case x@c_no_decls() => Some(x);
    case _ => None };
  val v_no_decls = f_no_decls _;
  def f_no_decls():T_Decls = c_no_decls().register;
  val p_no_decls = new PatternFunction[(T_Decls)](u_no_decls);

  case class c_xcons_decls(v_ds : T_Decls,v_d : T_Decl) extends T_Decls(t_Decls) {
    override def children : List[Node] = List(v_ds,v_d);
    override def toString() : String = Debug.with_level {
      "xcons_decls("+ v_ds + ","+ v_d+ ")";
    }
  }
  def u_xcons_decls(x:Any) : Option[(T_Decls,T_Decls,T_Decl)] = x match {
    case x@c_xcons_decls(v_ds,v_d) => Some((x,v_ds,v_d));
    case _ => None };
  val v_xcons_decls = f_xcons_decls _;
  def f_xcons_decls(v_ds : T_Decls, v_d : T_Decl):T_Decls = c_xcons_decls(v_ds,v_d).register;
  val p_xcons_decls = new PatternFunction[(T_Decls,T_Decls,T_Decl)](u_xcons_decls);

  case class c_decl(v_id : T_String,v_ty : T_Type) extends T_Decl(t_Decl) {
    override def children : List[Node] = List(v_ty);
    override def toString() : String = Debug.with_level {
      "decl("+ v_id + ","+ v_ty+ ")";
    }
  }
  def u_decl(x:Any) : Option[(T_Decl,T_String,T_Type)] = x match {
    case x@c_decl(v_id,v_ty) => Some((x,v_id,v_ty));
    case _ => None };
  val v_decl = f_decl _;
  def f_decl(v_id : T_String, v_ty : T_Type):T_Decl = c_decl(v_id,v_ty).register;
  val p_decl = new PatternFunction[(T_Decl,T_String,T_Type)](u_decl);

  case class c_integer_type() extends T_Type(t_Type) {
    override def children : List[Node] = List();
    override def toString() : String = Debug.with_level {
      "integer_type("+ ")";
    }
  }
  def u_integer_type(x:Any) : Option[(T_Type)] = x match {
    case x@c_integer_type() => Some(x);
    case _ => None };
  val v_integer_type = f_integer_type _;
  def f_integer_type():T_Type = c_integer_type().register;
  val p_integer_type = new PatternFunction[(T_Type)](u_integer_type);

  case class c_string_type() extends T_Type(t_Type) {
    override def children : List[Node] = List();
    override def toString() : String = Debug.with_level {
      "string_type("+ ")";
    }
  }
  def u_string_type(x:Any) : Option[(T_Type)] = x match {
    case x@c_string_type() => Some(x);
    case _ => None };
  val v_string_type = f_string_type _;
  def f_string_type():T_Type = c_string_type().register;
  val p_string_type = new PatternFunction[(T_Type)](u_string_type);

  case class c_no_stmts() extends T_Stmts(t_Stmts) {
    override def children : List[Node] = List();
    override def toString() : String = Debug.with_level {
      "no_stmts("+ ")";
    }
  }
  def u_no_stmts(x:Any) : Option[(T_Stmts)] = x match {
    case x@c_no_stmts() => Some(x);
    case _ => None };
  val v_no_stmts = f_no_stmts _;
  def f_no_stmts():T_Stmts = c_no_stmts().register;
  val p_no_stmts = new PatternFunction[(T_Stmts)](u_no_stmts);

  case class c_xcons_stmts(v_ss : T_Stmts,v_s : T_Stmt) extends T_Stmts(t_Stmts) {
    override def children : List[Node] = List(v_ss,v_s);
    override def toString() : String = Debug.with_level {
      "xcons_stmts("+ v_ss + ","+ v_s+ ")";
    }
  }
  def u_xcons_stmts(x:Any) : Option[(T_Stmts,T_Stmts,T_Stmt)] = x match {
    case x@c_xcons_stmts(v_ss,v_s) => Some((x,v_ss,v_s));
    case _ => None };
  val v_xcons_stmts = f_xcons_stmts _;
  def f_xcons_stmts(v_ss : T_Stmts, v_s : T_Stmt):T_Stmts = c_xcons_stmts(v_ss,v_s).register;
  val p_xcons_stmts = new PatternFunction[(T_Stmts,T_Stmts,T_Stmt)](u_xcons_stmts);

  case class c_block_stmt(v_block : T_Block) extends T_Stmt(t_Stmt) {
    override def children : List[Node] = List(v_block);
    override def toString() : String = Debug.with_level {
      "block_stmt("+ v_block+ ")";
    }
  }
  def u_block_stmt(x:Any) : Option[(T_Stmt,T_Block)] = x match {
    case x@c_block_stmt(v_block) => Some((x,v_block));
    case _ => None };
  val v_block_stmt = f_block_stmt _;
  def f_block_stmt(v_block : T_Block):T_Stmt = c_block_stmt(v_block).register;
  val p_block_stmt = new PatternFunction[(T_Stmt,T_Block)](u_block_stmt);

  case class c_assign_stmt(v_e1 : T_Expr,v_e2 : T_Expr) extends T_Stmt(t_Stmt) {
    override def children : List[Node] = List(v_e1,v_e2);
    override def toString() : String = Debug.with_level {
      "assign_stmt("+ v_e1 + ","+ v_e2+ ")";
    }
  }
  def u_assign_stmt(x:Any) : Option[(T_Stmt,T_Expr,T_Expr)] = x match {
    case x@c_assign_stmt(v_e1,v_e2) => Some((x,v_e1,v_e2));
    case _ => None };
  val v_assign_stmt = f_assign_stmt _;
  def f_assign_stmt(v_e1 : T_Expr, v_e2 : T_Expr):T_Stmt = c_assign_stmt(v_e1,v_e2).register;
  val p_assign_stmt = new PatternFunction[(T_Stmt,T_Expr,T_Expr)](u_assign_stmt);

  case class c_intconstant(v_i : T_Integer) extends T_Expr(t_Expr) {
    override def children : List[Node] = List();
    override def toString() : String = Debug.with_level {
      "intconstant("+ v_i+ ")";
    }
  }
  def u_intconstant(x:Any) : Option[(T_Expr,T_Integer)] = x match {
    case x@c_intconstant(v_i) => Some((x,v_i));
    case _ => None };
  val v_intconstant = f_intconstant _;
  def f_intconstant(v_i : T_Integer):T_Expr = c_intconstant(v_i).register;
  val p_intconstant = new PatternFunction[(T_Expr,T_Integer)](u_intconstant);

  case class c_strconstant(v_s : T_String) extends T_Expr(t_Expr) {
    override def children : List[Node] = List();
    override def toString() : String = Debug.with_level {
      "strconstant("+ v_s+ ")";
    }
  }
  def u_strconstant(x:Any) : Option[(T_Expr,T_String)] = x match {
    case x@c_strconstant(v_s) => Some((x,v_s));
    case _ => None };
  val v_strconstant = f_strconstant _;
  def f_strconstant(v_s : T_String):T_Expr = c_strconstant(v_s).register;
  val p_strconstant = new PatternFunction[(T_Expr,T_String)](u_strconstant);

  case class c_variable(v_id : T_String) extends T_Expr(t_Expr) {
    override def children : List[Node] = List();
    override def toString() : String = Debug.with_level {
      "variable("+ v_id+ ")";
    }
  }
  def u_variable(x:Any) : Option[(T_Expr,T_String)] = x match {
    case x@c_variable(v_id) => Some((x,v_id));
    case _ => None };
  val v_variable = f_variable _;
  def f_variable(v_id : T_String):T_Expr = c_variable(v_id).register;
  val p_variable = new PatternFunction[(T_Expr,T_String)](u_variable);

  override def finish() : Unit = {
    super.finish();
  }

}

