// Generated by aps2scala version 0.3.6
import basic_implicit._;
object flat_implicit {
  val flat_loaded = true;
}
import flat_implicit._;

trait C_FLAT_LATTICE[T_Result, T_E] extends C_TYPE[T_Result] with C_COMBINABLE[T_Result] with C_LATTICE[T_Result] with C_PRINTABLE[T_Result] {
  val p_fbottom : PatternFunction[(T_Result)];
  def v_fbottom : () => T_Result;
  val p_ftop : PatternFunction[(T_Result)];
  def v_ftop : () => T_Result;
  val p_normal : PatternFunction[(T_Result,T_E)];
  def v_normal : (T_E) => T_Result;
  def v_bottom : T_Result;
  def v_top : T_Result;
  val v_string : (T_Result) => T_String;
  val v_compare : (T_Result,T_Result) => T_Boolean;
  val v_compare_equal : (T_Result,T_Result) => T_Boolean;
  val v_join : (T_Result,T_Result) => T_Result;
  val v_meet : (T_Result,T_Result) => T_Result;
  val v_lift : (T_E) => T_Result;
  val v_applyf1 : ((T_E) => T_E,T_Result) => T_Result;
  val v_applyf2 : ((T_E,T_E) => T_E,T_Result,T_Result) => T_Result;
  def v_initial : T_Result;
  val v_combine : (T_Result,T_Result) => T_Result;
}

abstract class T_FLAT_LATTICE[T_E](t : C_FLAT_LATTICE[T_FLAT_LATTICE[T_E],T_E]) extends Value(t) { }

class M_FLAT_LATTICE[T_E](name : String,val t_E : C_TYPE[T_E] with C_BASIC[T_E] with C_PRINTABLE[T_E])
  extends I_TYPE[T_FLAT_LATTICE[T_E]](name)
  with C_FLAT_LATTICE[T_FLAT_LATTICE[T_E],T_E]
{
  val t_Result : this.type = this;
  case class c_fbottom() extends T_Result(t_Result) {
    override def toString() : String = Debug.with_level {
      "fbottom("+ ")";
    }
  }
  def u_fbottom(x:Any) : Option[(T_Result)] = x match {
    case x@c_fbottom() => Some(x);
    case _ => None };
  val v_fbottom = f_fbottom _;
  def f_fbottom():T_Result = c_fbottom();
  val p_fbottom = new PatternFunction[(T_Result)](u_fbottom);

  case class c_ftop() extends T_Result(t_Result) {
    override def toString() : String = Debug.with_level {
      "ftop("+ ")";
    }
  }
  def u_ftop(x:Any) : Option[(T_Result)] = x match {
    case x@c_ftop() => Some(x);
    case _ => None };
  val v_ftop = f_ftop _;
  def f_ftop():T_Result = c_ftop();
  val p_ftop = new PatternFunction[(T_Result)](u_ftop);

  case class c_normal(v_value : T_E) extends T_Result(t_Result) {
    override def toString() : String = Debug.with_level {
      "normal("+ v_value+ ")";
    }
  }
  def u_normal(x:Any) : Option[(T_Result,T_E)] = x match {
    case x@c_normal(v_value) => Some((x,v_value));
    case _ => None };
  val v_normal = f_normal _;
  def f_normal(v_value : T_E):T_Result = c_normal(v_value);
  val p_normal = new PatternFunction[(T_Result,T_E)](u_normal);

  val v_bottom:T_Result = v_fbottom();
  val v_top:T_Result = v_ftop();
  override val v_string = f_string _;
  override def f_string(v_x : T_Result):T_String = {

    v_x match {
      case p_fbottom(_) => {
        return "BOT";
      }
      case p_ftop(_) => {
        return "TOP";
      }
      case p_normal(_,v_v) => {
        return new M__basic_18[ T_String](t_String).v__op_ss("LIFT(",new M__basic_18[ T_String](t_String).v__op_ss(t_E.v_string(v_v),")"));
      }
    }
    throw Evaluation.UndefinedAttributeException("local string");
  }

  val v_compare = f_compare _;
  def f_compare(v_v1 : T_Result, v_v2 : T_Result):T_Boolean = {

    v_v1 match {
      case p_fbottom(_) => {
        return new M__basic_2[ T_Result](t_Result).v__op_w0(v_v2,v_v1);
      }
      case p_normal(_,v_0) => {
        return new M__basic_2[ T_Result](t_Result).v__op_0(v_v2,v_top);
      }
      case _ => {
        return v_false;
      }
    }
    throw Evaluation.UndefinedAttributeException("local compare");
  }

  val v_compare_equal = f_compare_equal _;
  def f_compare_equal(v_v1 : T_Result, v_v2 : T_Result):T_Boolean = {

    v_v1 match {
      case p_ftop(_) => {
        return new M__basic_2[ T_Result](t_Result).v__op_0(v_v1,v_v2);
      }
      case p_normal(_,v_0) => {
        return v_or(new M__basic_2[ T_Result](t_Result).v__op_0(v_v1,v_v2),new M__basic_2[ T_Result](t_Result).v__op_0(v_v2,v_top));
      }
      case _ => {
        return v_true;
      }
    }
    throw Evaluation.UndefinedAttributeException("local compare_equal");
  }

  val v_join = f_join _;
  def f_join(v_v1 : T_Result, v_v2 : T_Result):T_Result = {

    v_v1 match {
      case p_fbottom(_) => {
        return v_v2;
      }
      case p_normal(_,v_0) => {
        { val cond = v_or(new M__basic_2[ T_Result](t_Result).v__op_0(v_v2,v_bottom),new M__basic_2[ T_Result](t_Result).v__op_0(v_v2,v_v1));
          if (cond) {
            return v_v1;
          }
          if (!cond) {
            return v_top;
          }
        }
      }
      case _ => {
        return v_top;
      }
    }
    throw Evaluation.UndefinedAttributeException("local join");
  }

  val v_meet = f_meet _;
  def f_meet(v_v1 : T_Result, v_v2 : T_Result):T_Result = {

    v_v1 match {
      case p_ftop(_) => {
        return v_v2;
      }
      case p_normal(_,v_0) => {
        { val cond = v_or(new M__basic_2[ T_Result](t_Result).v__op_0(v_v2,v_top),new M__basic_2[ T_Result](t_Result).v__op_0(v_v2,v_v1));
          if (cond) {
            return v_v1;
          }
          if (!cond) {
            return v_bottom;
          }
        }
      }
      case _ => {
        return v_bottom;
      }
    }
    throw Evaluation.UndefinedAttributeException("local meet");
  }

  val v_lift = f_lift _;
  def f_lift(v_e : T_E):T_Result = v_normal(v_e);
  val v_applyf1 = f_applyf1 _;
  def f_applyf1(v_base : (T_E) => T_E, v_x : T_Result):T_Result = {

    v_x match {
      case p_normal(_,v_v) => {
        return v_normal(v_base(v_v));
      }
      case _ => {
        return v_x;
      }
    }
    throw Evaluation.UndefinedAttributeException("local applyf1");
  }

  val v_applyf2 = f_applyf2 _;
  def f_applyf2(v_base : (T_E,T_E) => T_E, v_x1 : T_Result, v_x2 : T_Result):T_Result = {

    v_x1 match {
      case p_normal(_,v_v1) => {
        v_x2 match {
          case p_normal(_,v_v2) => {
            return v_normal(v_base(v_v1,v_v2));
          }
          case _ => {
            return v_x2;
          }
        }
      }
      case _ => {
        { val cond = new M__basic_2[ T_Result](t_Result).v__op_0(v_x2,v_bottom);
          if (cond) {
            return v_x2;
          }
          if (!cond) {
            return v_x1;
          }
        }
      }
    }
    throw Evaluation.UndefinedAttributeException("local applyf2");
  }

  val v_initial : T_Result = v_bottom;
  val v_combine = f_combine _;
  def f_combine(v_x1 : T_Result, v_x2 : T_Result):T_Result = v_join(v_x1,v_x2);
  override def finish() : Unit = {
    super.finish();
  }

}

